# Image-processing-algorithms

Файл otsu_binarization.py содержит основной алгоритм, а файл test.py используется для тестирования алгоритма в различных ситуациях; Чтобы тестировать просто запустите файл test.py.

Lab1-Разработать алгоритм Оцу — это файл Jupyter, который включает объяснение алгоритма и его шагов, а также визуализацию тестирования в 10 различных сценариях.

Файл test1 использует библиотеки cv2 и matplotlib для тестирования результатов обработки алгоритма на реальных изображениях. Файл test.png — это изображение голубого неба с белыми облаками. После запуска программы она выведет бинаризованное изображение (результат выглядит довольно хорошо, идеально разделяя белые облака и голубое небо).

Для второго теста я сгенерировал изображение с низкой контрастностью, чтобы определить, классифицирует ли алгоритм все пиксели в один класс. В тестовом случае мы ожидаем, что алгоритм на изображениях с низкой контрастностью отнесет все пиксели к одному классу, поскольку нет явного переднего и заднего планов. Фактический результат показал, что алгоритм определяет пиксели, немного отличающиеся от фона, как передний план, что указывает на то, что алгоритм может не соответствовать нашим ожиданиям в условиях низкой контрастности.

Что касается того, хорошо это или плохо, на мой взгляд, алгоритм способен обнаруживать мельчайшие различия в уровнях серого, что может быть полезно в некоторых приложениях, требующих высокой чувствительности, например, для обнаружения небольших изменений или дефектов в изображениях. Однако это также может привести к тому, что шум или небольшие изменения яркости будут ошибочно приняты за передний план, что приведет к чрезмерной сегментации.

### О цели каждого теста и проверке утверждений

**Test1:test_high_contrast_image**

**Цель:** Проверить, может ли алгоритм правильно разделить передний и задний план на изображении с высоким контрастом.

**assert:** Проход по бинаризованному изображению: проверить, равны ли значения пикселей в верхней половине 0 (фон). Проверить, равны ли значения пикселей в нижней половине 1 (передний план).

**Test2:test_low_contrast_image**

**Цель:** Оценить производительность алгоритма на изображениях с низким контрастом.

**assert:** Проверить, разделяет ли алгоритм все пиксели в одну и ту же категорию.

**Test3:test_noisy_image**

**Цель:** Проверить стабильность алгоритма и корректность вывода на изображении со случайным шумом.

**assert:** Из-за случайного характера шумового изображения невозможно предсказать вывод. Поэтому проверим, что каждый пиксель в бинаризованном результате равен 0 или 1, чтобы убедиться, что вывод корректен.

**Test4:test_blank_image**

**Цель:** Проверить, может ли алгоритм стабильно работать и давать согласованный вывод, когда все значения пикселей одинаковы.

**assert:** Поскольку все значения пикселей одинаковы, алгоритм может отнести все пиксели к одной категории (все 0 или все 1). Проверим, что все значения пикселей в бинаризованном результате одинаковы.

**Test5:test_gradient_image**

**Цель:** Проверить, может ли алгоритм правильно найти порог и выполнить сегментацию на изображении с постепенно изменяющимися значениями серого.

**assert:** Проверить, содержит ли бинаризованный результат как 0, так и 1

**Test6:test_multiple_thresholds_image**

**Цель:** Протестировать эффективность сегментации алгоритма, когда на изображении присутствуют несколько областей с разными уровнями серого.

**assert:** Проверить, алгоритм отнесет ли темно-серые области к фону (0), а области среднего и светлого серого — к переднему плану (1). 

**Test7:test_salt_and_paper_noise**

**Цель:** Проверить, может ли алгоритм правильно сегментировать основную часть изображения в присутствии шумов типа "соль с перцем".

**assert:** Подсчитать количество 0 и 1 в бинаризованном результате. Проверить, что большинство пикселей отнесены к одной категории.(указывает на то, что алгоритм не был нарушен небольшим количеством шума.)

**Test8:test_checkerboard_pattern**

**Цель:** Проверить способность алгоритма сегментировать высокочастотные шаблоны.

**assert:** На основе положения пикселей ожидается, что бинаризованный результат будет совпадать с исходным шахматным узором. Проверить, соответствует ли бинарное значение каждого пикселя ожидаемому.

**Test9:test_image_with_text**

**Цель:** Протестировать эффективность алгоритма на изображении, имитирующем текст, и проверить его способность различать текст.

**assert:** Проверить, что пиксели в области текста правильно отнесены к переднему плану (0), а пиксели в фоновой области классифицированы как фон (1).

**Test10:test_large_image**

**Цель:** Оценить производительность и правильность алгоритма на большом изображении, чтобы убедиться, что алгоритм масштабируется до размеров реальных приложений.

**assert:** Проверить для каждого пикселя в зависимости от его положения, соответствует ли его бинаризованное значение ожидаемому.
